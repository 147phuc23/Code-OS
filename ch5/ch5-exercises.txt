== Exercise 5.1 ==
** Question ** 
Modify the program in listing 5-3 to use standard file I/O system
calls (open() and lseek()) and the off_t data type.  Compile the
program with the _FILE_OFFSET_BITS macro set to 64, and test it to
show that a large file can be successfully created.

** Answer **
[TODO]

== Exercise 5.2 ==
** Question **
Write a program that opens and existing file for writing with the
O_APPEND flag, and then seeks to the beginning of the file before
writing some data.  Where does the data appear in the file?  Why?

** Answer **n
[TODO]

== Exercise 5.3 ==
** Question **
This exercise is designed to demonstrate why the atomicity guaranteed
by opening a file with the O_APPEND flag is necessary.  Wirte a
program that takes up to three command-line arguments:

    $ atomic_append <filename> <num-bytes> [x]

This program should open the specified filename (creating it if
necessary) and append num-bytes bytes to the file by using write() to
write a byte at a time.  By default, the program should open the file
with the O_APPEND flag, but if a third command-line argument (x) is
supplied, th ethe O_APPEND flag should be omitted, and instead, the
program should perform and lseek(fd, 0, SEEK_END) call before each
write().  Run two instances of this program at the same time without
the x argument to write 1 million bytes to the same file:

    $ atomic_append f1 1000000 & atomic_append f1 1000000

Repeat the same steps, writing to a different file, but this time
specifying the x argument:

    $ atomic_append f2 1000000 x & atomic_append f2 1000000 x

List the sizes of the files f1 and f2 using `ls -l` and explain the
difference.

** Answer **
[TODO]

== Question 5-4 ==
** Question **
Implement dup() and dup2() using fcntl() and, where necessary,
close().  (You may ignore the fact that dup2() and fcntl() return
different errno values for some error cases.)  For dup2(), remember to
handle the special case where oldfd equals newfd.  In this case, you
should check whether oldfd is valid, which can be done by, for
example, checking if fcntl(oldfd, F_GETFL) succeeds.  If oldfd is not
valid, then the function should return -1 with errrno set to EBADF.

** Answer **
[TODO]

== Question 5-5 ==
** Question **
Write a program to verify that duplicated file descriptors share a
file offset value and open file status flags.

** Answer **
[TODO]

== Question 5-6 ==
** Question **
After each of the calls to write() in th e following code, explain
what the content of the output file would be, and why:

    fd1 = open(file, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
    fd2 = dup(fd1);
    fd3 = open(file, O_RDWR);
    write(fd1, "Hello,", 6);
    write(fd2, " world", 6);
    write(fd1, "HELLO,", 6);
    write(fd3, "Gidday", 6);

** Answer **
[TODO]

== Question 5-7 ==
** Question **
Implemented readv() and writev() using read() and write(), and
suitable functions from the malloc package (Section 7.1.2).

** Answer **
[TODO]

